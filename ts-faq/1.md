```
> I've found a long-overlooked bug in TypeScript!
Here are some behaviors that may look like bugs, but aren't.
```

TypeScript 還滿多行為容易被誤解成 bug, ~~但其實是設計上的缺陷~~/known issue/~~feature~~ 

```
- These two empty classes can be used in place of each other
   - See the [FAQ Entry on this page(https://github.com/Microsoft/TypeScript/wiki/FAQ#why-do-these-empty-classes-behave-strangely)
```

範例 code 為以下

```typescript
class Empty { /* empty */ }

var e2: Empty = window;
```

這題核心其實來自 "Why are all types assignable to empty interfaces?"，簡單來說，TS 的 empty interface 跟 golang 的 {} 有點像，都是接近 any 的型別，基本上什麼都會過，能避則避

---

```
-   I can use a non-`void`-returning function where one returning `void` is expected
    -   See the [FAQ Entry on this page](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-returning-non-void-assignable-to-function-returning-void)
    -   Prior discussion at #4544
```

```
-   I'm allowed to use a shorter parameter list where a longer one is expected
    -   See the [FAQ Entry on this page](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-with-fewer-parameters-assignable-to-functions-that-take-more-parameters)
    -   Prior discussion at #370, #9300, #9765, #9825, #13043, #16871, #13529, #13977, #17868, #20274, #20541, #21868, #26324, #30876
```

這題跟算是跟已經討論廣泛的 "Substitutability" https://github.com/Microsoft/TypeScript/wiki/FAQ#substitutability 有關，簡單來說 TS 的 interface/function params 都不是 exact types (這也是一個 issue https://github.com/microsoft/TypeScript/issues/12936 )，所有的 record/function arity 對比，只需要部分吻合就算是 match (這其實有導致一些比較不明顯的問題，其他 Q 可能會講到)

---

```
-   `private` class members are actually visible at runtime
    -   See the [FAQ Entry on this page](https://github.com/Microsoft/TypeScript/wiki/FAQ#you-should-emit-classes-like-this-so-they-have-real-private-members) for a commonly suggested "fix"
    -   Prior discussion at #564, #1537, #2967, #3151, #6748, #8847, #9733, #11033
```

TLDR 這是一個誤用，這個 TS 專屬的 private 寫法其實比較接近 public static，也只有型別檢查上的用處（基本上原問題就不 ok 了，runtime 行為長怎樣 TS 其實不會負責

真正的 private 寫法應該是 `#privateMethod() {}` https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields

---

-   This conditional type returns `never` when it should return the true branch.
    -   See this [issue](https://github.com/microsoft/TypeScript/issues/31751) for discussion about _distributive conditional types_.

這題 issue 其實回答的就很好了，但描述裡比較多是「直述」TS 的行為，我試著用另個方法講講看

緣由比較是來自發問者對於 never 確切行為的不熟悉，never 在 TS 裡，除了是一個永遠不該成為 compute result 的型別外，他還被看待成有點像個「空集合/Empty Set」，而且是數學上「不包含任何 Set 的 Set」（有點悖論的感覺）

而不包含任何 Set 的 Set，也就不會包含他自己，所以 `never extends never ?` 是不能產出任何有意義內容的，才導致他在 TS 哲學上實作成了 `never`

(我只是照我的感受回答，沒有深刻探究)

---

-   This mapped type returns a primitive type, not an object type.
    -   Mapped types declared as `{ [ K in keyof T ]: U }` where T is a type parameter are known as _homomorphic mapped types_, which means that the mapped type is a structure preserving function of `T`. When type parameter `T` is instantiated with a primitive type the mapped type evaluates to the same primitive.


-   A method and a function property of the same type behave differently.
    -   Methods are always bivariant in their argument, while function properties are contravariant in their argument under `strictFunctionTypes`. More discussion [here](https://github.com/microsoft/TypeScript/pull/18654).
-   Export maps aren't respected.
    -   TypeScript's support for export maps is recent, and requires `moduleResolution` be set to `node16` or `nodenext` to be respected.
-   A default import of a commonjs module with a default in a esm file doesn't seem to be the default export of that module when `module` is `node16` or `nodenext`.
    -   TypeScript is exposing `node`'s behavior here - when a esm module default imports a commonjs module, that whole commonjs module is made available as the default import. If you then want the actual default member of that module, you'll need to access the `default` member of that import. Refer to the [node documentation](https://nodejs.org/api/esm.html#commonjs-namespaces) for more information.